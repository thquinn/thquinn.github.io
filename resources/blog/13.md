# Scroetry
##### August 7, 2023

<img src="resources/images/blog/13-0.png" style="width: 66%;" />

We all know about pangrams:

<div style="text-align: center;">
	<p><i>The quick brown fox jumps over the lazy dog.</i></p>
	<p><i>Pack my box with five dozen liquor jugs.</i></p>
	<p><i>Sphinx of black quartz, judge my vow.</i></p>
</div>

Those are good, even if they use some letters multiple times. If you don't allow that, you get something like:

<div style="text-align: center;">
	<p><i>Mr. Jock, TV-quiz PhD, bags few lynx.</i></p>
</div>

Honestly not that bad, considering! (Though I imagine he didn't spend six years in TV-quiz school to be called "mister.") These are max restrictive, of course, and the whole area feels pretty depleted. Pretty picked over. Let's give ourselves more letters to work with, and extra leeway besides, by using Scrabble tiles. A whole bag's worth!

<img src="resources/images/blog/13-1.png" style="width: 50%;" />

I found some folks that have done this before, but not in a while: some funny ones at the bottom of [this 1999 blog post](https://www.kith.org/words/1999/01/03/aaalphabets2/) and [a longformer from Y2K](http://www.cadaeic.net/scrpoem.htm) that got around the early internet. Nobody gave these things a name, so it falls to me. From the trademark *Scrabble* and the Greco-Latin *poēma*: **scroem.** Let's write some scroetry.

<div id = "blogPoemTomsPoems" class="blogPoemPoems"></div>

Those blank tiles are clutch. You should give it a try! Here are some handy tools:
* [Scrabble Word Finder](https://scrabblewordfinder.org/)
* [Onelook](https://www.onelook.com/)
* [Thesaurus](https://www.thesaurus.com/)
* [ChatGPT](https://chat.openai.com/)
* [Multiple Word Anagram Solver](https://www.thewordfinder.com/multiple-word-anagram-solver/)

<div id="blogPoemError"></div>
<div id="blogPoemControls">
	<div><b>Scroetry Editor</b></div>
	<div>
		<label>Author:</label>
		<input id="blogPoemAuthor" maxlength="16" />
	</div>
	<button id="blogPoemSubmit" disabled>Submit</button>
</div>
<div>
	<textarea id="blogPoemInput" rows="4"></textarea>
</div>
<div id="blogPoemLettersLeft"></div>
<p>Blanks: <span id="blogPoemBlanksUsed"></span></p>

<h3 id="blogPoemUserPoemsHeader" style="display: none;">Submitted Scroems</h3>
<div id="blogPoemUserPoems" class="blogPoemPoems"></div>

#STARTSCRIPTS
const dbURL = 'https://scroems-default-rtdb.firebaseio.com/scroems.json';
const dictURL = './resources/txt/collinsdict2019.txt';
const tiles = 'AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOPPQRRRRRRSSSSTTTTTTUUUUVVWWXYYZ??';
const tileScores = '111111111333322221111111111114422244111111111851111331111111111111133X111111111111111111114444844X';
const isLetter = (c) => {
	let n = c.charCodeAt(0);
	return (n >= 65 && n < 91) || (n >= 97 && n < 123);
}
const maxLines = 8;

const tomsPoems = [
	"With my emphatic jive-quaking — dabbing at wise, nauseated lowland gorillas — our ape zoo excursion veered into effrontery.",
	"Bigeye was known to be a Liquid Crystal Deviant, per the jocular, gonzo grapevine murmurations of a dopehead exile misfit.",
	"An overbearing old hepcat fogey insinuated\nThis medium of enjoyable, vexing esoterica\nWould work as a top tranquilizer",
	"Cautionary arboretum overview:\nloud squeezebox\nsinister yellowjacket\ndithering hooligan\neffing empanadas\nI depart",
	"global vision\nquick betattering incision\nplunder femoral spray\ninjure to outweigh\nheavy doze the dead\nwax seafoam-red",
]
const wordSets = []
let dictSet;

const fetchScroems = () => {
	const promises = [window.fetch(dbURL)];
	if (!dictSet) {
		promises.push(window.fetch(dictURL));
	}
	try {
		Promise.all(promises).then((values) => Promise.all(values.map((v, i) => {
			return i == 0 ? v.json() : v.text();
		}))).then((values) => {
			if (values.length > 1) {
				const dictResponse = values[1];
				dictSet = new Set(dictResponse.split(/\r?\n/));
			}
			wordSets.length = 0; // clear
			blogPoemTomsPoems.innerHTML = '';
			for (const tomsPoem of tomsPoems) {
				appendPoem(blogPoemTomsPoems, tomsPoem);
			}
			blogPoemUserPoems.innerHTML = '';
			const userPoems = Object.values(values[0]).reverse();
			for (const r of userPoems) {
				const poem = r.scroem;
				const author = r.author;
				if (!checkScroem(poem)) {
					continue;
				}
				blogPoemUserPoemsHeader.style.display = 'block';
				appendPoem(blogPoemUserPoems, poem, author, r.timestamp)
			}
		});
	} catch (e) {console.log('Failed to fetch.', e)}
}
const appendPoem = (parent, poem, author, timestamp) => {
	const poemSet = convertPoemToWordSet(poem);
	if (!wordSetIsScrabbly(poemSet)) {
		// This poem contains too many fake words.
		return;
	}
	if (isDuplicateWordSet(poemSet)) {
		// This poem is too similar to others before it.
		return;
	}
	if (hasTooManyLines(poem)) {
		return;
	}
	wordSets.push(poemSet);
	// Add to DOM.
	const d = document.createElement('div');
	d.innerHTML = poem.replaceAll('\n', '<br />');
	d.classList.add('blogPoemPoem');
	if (author) {
		const c = document.createElement('cite');
		c.innerHTML = '—' + author;
		d.appendChild(c);
	}
	if (timestamp) {
		const date = new Date(timestamp);
		const c = document.createElement('cite');
		c.innerHTML = date.toDateString();
		d.appendChild(c);
	}
	parent.appendChild(d);
}
const wordRegex = /'?\w[\w']*(?:\w+)*'?/g;
const convertPoemToWordSet = (poem) => {
	poem = poem.replaceAll('\u2019', '\''); // fake apostrophes
	return new Set(poem.toUpperCase().match(wordRegex));
}
const wordSetIsScrabbly = (poemWords) => {
	let scrabbleCount = 0;
	for (const word of poemWords) {
		if (dictSet.has(word)) {
			scrabbleCount++;
		}
	}
	return scrabbleCount / poemWords.size >= .75;
}
const isDuplicateWordSet = (poemWords) => {
	return wordSets.some(s => wordSetsAreTheSame(poemWords, s));
}
const wordSetsAreTheSame = (set1, set2) => {
	let intersectionSize = 0;
	for (const s of set1) {
		if (set2.has(s)) {
			intersectionSize++;
		}
	}
	return intersectionSize > Math.min(set1.size, set2.size) / 2;
}
const hasTooManyLines = (poem) => {
	return (poem.match(/\n/g) || '').length >= maxLines;
}

const setblogPoemLettersLeft = () => {
	const validScroem = checkScroem(blogPoemInput.value, true);
	blogPoemSubmit.disabled = !validScroem || !blogPoemAuthor.value;
}
const checkScroem = (poem, isEditor) => {
	poem = poem.toUpperCase();
	let tilesCopy = tiles;
	let over = '';
	if (isEditor) {
		blogPoemError.innerHTML = '';
		blogPoemLettersLeft.innerHTML = '';
		blogPoemBlanksUsed.innerHTML = '';
		blogPoemBlanksUsed.classList.remove(...blogPoemBlanksUsed.classList);
	}
	for (const c of poem) {
		if (isLetter(c)) {
			let replaced = tilesCopy.replace(c, '');
			if (replaced.length == tilesCopy.length) {
				replaced = replaced.replace('?', '');
				if (replaced.length == tilesCopy.length) {
					over += c;
				} else if (isEditor) {
					blogPoemBlanksUsed.innerHTML += c;
				}
			}
			tilesCopy = replaced;
		}
	}
	if (isEditor) {
		over = over.split('').sort().join('');
		for (const c of over) {
			blogPoemBlanksUsed.innerHTML += c;
			if (blogPoemBlanksUsed.classList.length === 0) {
				blogPoemBlanksUsed.classList.add('blogPoemTooManyBlanks');
			}
		}
		let j = 0;
		for (let i = 0; i < tiles.length; i++) {
			const c = tiles[i];
			let score = i < tileScores.length ? tileScores[i] : '';
			if (score == 'X') { score = '10'; }
			const span = document.createElement('span');
			span.innerHTML = c == '?' ? ' ' : c + '<sub>' + score + '</sub>';
			if (tiles[i] == tilesCopy[j]) {
				j++;
			} else {
				span.classList.add("blogpoemdim");
			}
			blogPoemLettersLeft.appendChild(span);
		}
		blogPoemBlanksUsed.innerHTML = blogPoemBlanksUsed.innerHTML.split("").sort().join("");
	}
	return tilesCopy.split('').every(c => c == '?') && !over;
}
setblogPoemLettersLeft();
blogPoemAuthor.addEventListener('input', setblogPoemLettersLeft);
blogPoemInput.addEventListener('input', setblogPoemLettersLeft);
blogPoemSubmit.addEventListener('click', () => {
	submitPoem(blogPoemAuthor.value, blogPoemInput.value);
});

const submitPoem = async (author, poem) => {
	const poemSet = convertPoemToWordSet(poem);
	if (!wordSetIsScrabbly(poemSet)) {
		blogPoemError.innerHTML = '75% or more of the unique words in a scroem must be legal in Scrabble.';
		return;
	}
	if (isDuplicateWordSet(poemSet)) {
		blogPoemError.innerHTML = 'This is too similar to a previous scroem.';
		return;
	}
	if (hasTooManyLines(poem)) {
		blogPoemError.innerHTML = `Scroems can have a maximum of ${maxLines} lines.`;
		return;
	}
	window.fetch(dbURL, {
		method: 'POST',
		body: JSON.stringify({
			"author": author,
			"scroem": poem,
			"timestamp": { ".sv": "timestamp" },
		}),
	}).then(fetchScroems);
}
fetchScroems();