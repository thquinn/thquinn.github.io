# Test
##### July 24, 2025

<div style="display: flex; justify-content: center;">
	<canvas id="testo" draggable="false" onmousedown="return false;" />
</div>
<div>
	<button id="buttonRootSim">Root</button>
	<button id="buttonSelectSim">Select</button>
</div>

#STARTSCRIPTS
// TTT Logic
function getWinner(board) {
	if (board[0] != 0) {
		if ((board[0] == board[1] && board[0] == board[2]) ||
			(board[0] == board[3] && board[0] == board[6]) ||
			(board[0] == board[4] && board[0] == board[8])) return board[0];
	}
	if (board[1] != 0 && board[1] == board[4] && board[1] == board[7]) return board[1];
	if (board[3] != 0 && board[3] == board[4] && board[3] == board[5]) return board[3];
	if (board[8] != 0) {
		if ((board[8] == board[7] && board[8] == board[6]) ||
			(board[8] == board[5] && board[8] == board[2])) return board[8];
	}
	if (board[2] != 0 && board[2] == board[4] && board[2] == board[6]) return board[2];
	return 0;
}
function isDraw(board) {
	for (let i = 0; i < 9; i++) {
		if (board[i] == 0) return false;
	}
	return true;
}
function getChildStates(board) {
    // Generate all possible moves
    const player = board[9];
    const nextPlayer = -player;
    const moves = [];
    
    for (let i = 0; i < 9; i++) {
        if (board[i] === 0) {
            const newBoard = [...board];
            newBoard[i] = player;
            newBoard[9] = nextPlayer;
            moves.push(newBoard);
        }
    }
    
    // Remove symmetric duplicates
    return removeDuplicates(moves);
}

function removeDuplicates(boards) {
    const unique = [];
    const seen = new Set();
    
    for (const board of boards) {
        const canonical = getCanonicalForm(board);
        const key = canonical.join(',');
        
        if (!seen.has(key)) {
            seen.add(key);
            unique.push(board);
        }
    }
    
    return unique;
}

function getCanonicalForm(board) {
    const grid = board.slice(0, 9);
    const player = board[9];
    
    // Generate all 8 symmetries (4 rotations Ã— 2 reflections)
    const symmetries = [];
    
    // Original and 3 rotations
    symmetries.push(grid);
    symmetries.push(rotate90(grid));
    symmetries.push(rotate180(grid));
    symmetries.push(rotate270(grid));
    
    // Horizontal reflection and its 3 rotations
    const reflected = reflect(grid);
    symmetries.push(reflected);
    symmetries.push(rotate90(reflected));
    symmetries.push(rotate180(reflected));
    symmetries.push(rotate270(reflected));
    
    // Find lexicographically smallest representation
    let canonical = symmetries[0];
    for (let i = 1; i < symmetries.length; i++) {
        if (isLexSmaller(symmetries[i], canonical)) {
            canonical = symmetries[i];
        }
    }
    
    return [...canonical, player];
}

function rotate90(grid) {
    // Rotate 90 degrees clockwise
    // Grid positions:
    // 0 1 2    6 3 0
    // 3 4 5 -> 7 4 1
    // 6 7 8    8 5 2
    return [
        grid[6], grid[3], grid[0],
        grid[7], grid[4], grid[1],
        grid[8], grid[5], grid[2]
    ];
}

function rotate180(grid) {
    // Rotate 180 degrees
    return [
        grid[8], grid[7], grid[6],
        grid[5], grid[4], grid[3],
        grid[2], grid[1], grid[0]
    ];
}

function rotate270(grid) {
    // Rotate 270 degrees clockwise (or 90 degrees counter-clockwise)
    return [
        grid[2], grid[5], grid[8],
        grid[1], grid[4], grid[7],
        grid[0], grid[3], grid[6]
    ];
}

function reflect(grid) {
    // Reflect horizontally (flip left-right)
    return [
        grid[2], grid[1], grid[0],
        grid[5], grid[4], grid[3],
        grid[8], grid[7], grid[6]
    ];
}

function isLexSmaller(a, b) {
    for (let i = 0; i < a.length; i++) {
        if (a[i] < b[i]) return true;
        if (a[i] > b[i]) return false;
    }
    return false;
}
const startingBoard = [1, 0, 0, 0, 0, 0, 0, 0, 0, -1];

// MCTS Logic
class MCTSNode {
	constructor(parent, board) {
		this.parent = parent;
		this.board = board;
		this.children = [];
		this.visits = 0;
		this.totalValue = 0;
	}
}
function select(node) {
	while (!node.terminal && node.visits > 0) {
		// Pick best UCT.
		let bestChild = null;
		let bestUCT = Number.NEGATIVE_INFINITY;
		for (let child of node.children) {
			if (child.visits == 0) return child;
			let uct = node.board[9] * child.totalValue / child.visits + Math.sqrt(Math.log(node.visits) / child.visits);
			if (uct > bestUCT) {
				bestChild = child;
				bestUCT = uct;
			}
		}
		node = bestChild;
	}
	return node;
}
function rolloutAndBackprop(node) {
	let rolloutNode = node;
	while (!rolloutNode.terminal) {
		rolloutNode = rolloutNode.children[Math.floor(Math.random() * rolloutNode.children.length)];
	}
	const value = rolloutNode.terminalValue;
	while (node != null) {
		node.visits++;
		node.totalValue += value;
		node = node.parent;
	}
}
function getRoot() {
	const root = new MCTSNode(null, startingBoard);
	const queue = [root];
	let count = 0;
	while (queue.length > 0) {
		count++;
		const current = queue.shift();
		const winner = getWinner(current.board);
		current.terminal = winner != 0 || isDraw(current.board);
		current.terminalValue = winner;
		if (!current.terminal) {
			const childBoards = getChildStates(current.board);
			for (const childBoard of childBoards) {
				const child = new MCTSNode(current, childBoard);
				current.children.push(child);
				queue.push(child);
			}
		}
	}
	return root;
}

function loadScript(url) {
	return new Promise((resolve, reject) => {
		const s = document.createElement("script");
		s.src = url;
		s.onload = resolve;
		s.onerror = reject;
		document.head.appendChild(s);
	});
}
(async () => {
	await loadScript('https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.0/pixi.min.js');
	const Viewport = await import('https://cdn.jsdelivr.net/npm/pixi-viewport@5.0.2/+esm');
	const app = new PIXI.Application({
		view: testo,
		width: 1600,
		height: 800,
		backgroundAlpha: 0.02,
		antialias: true,
		autoDensity: true,
		resolution: 8,
	});
	app.renderer.antialias = true;
	const viewport = new Viewport.Viewport({
	  screenWidth: window.innerWidth,
	  screenHeight: window.innerHeight,
	  worldWidth: 1000,
	  worldHeight: 1000,
	  events: app.renderer.events, // the interaction module is important for wheel to work properly when renderer.view is placed or scaled
	});
	viewport.isInteractive = () => true;
	app.stage.addChild(viewport);
	viewport.drag().pinch().wheel().decelerate();
	
	const graphics = new PIXI.Graphics();
	graphics.beginFill(0xE0E0E0);
	graphics.drawRoundedRect(0, 10, 256, 256, 48);
	graphics.beginFill(0xF0F0F0);
	graphics.drawRoundedRect(0, 0, 256, 256, 48);
	graphics.endFill();
	graphics.lineStyle(4, 0x404040);
	graphics.moveTo(94, 30);
	graphics.lineTo(94, 224);
	graphics.moveTo(162, 30);
	graphics.lineTo(162, 224);
	graphics.moveTo(30, 93);
	graphics.lineTo(226, 93);
	graphics.moveTo(30, 163);
	graphics.lineTo(226, 163);
	const boardTexture = app.renderer.generateTexture(graphics, { multisample: 8 });
	graphics.clear();
	graphics.lineStyle(48, 0x404040);
	graphics.drawCircle(0, 0, 100);
	const oTexture = app.renderer.generateTexture(graphics, { multisample: 8 });
	graphics.clear();
	graphics.lineStyle(24, 0x404040);
	graphics.moveTo(-50, -50);
	graphics.lineTo(50, 50);
	graphics.moveTo(50, -50);
	graphics.lineTo(-50, 50);
	const xTexture = app.renderer.generateTexture(graphics, { multisample: 8 });
	
	const nodeToContainer = new Map();
	const makeContainer = (node, x, y) => {
		const container = new PIXI.Container();
		const sprite = container.addChild(new PIXI.Sprite(boardTexture));
		sprite.width = sprite.height = 100;
		sprite.position.set(100, 100);
		for (let i = 0; i < 9; i++) {
			if (node.board[i] != 0) {
				const mark = container.addChild(new PIXI.Sprite(node.board[i] == -1 ? oTexture : xTexture));
				mark.width = mark.height = 20;
				mark.position.set(114 + i % 3 * 26, 112.5 + Math.floor(i / 3) * 26);
			}
		}
		const text = new PIXI.Text('', {fontFamily: 'Tahoma', fontSize: 16, fontWeight: '', fill: 0x808080, align: 'center'});
		text.position.set(170, 92);
		container.addChild(text);
		container.text = text;
		const visitText = new PIXI.Text('', {fontFamily: 'Tahoma', fontSize: 16, fontWeight: 'bold', fill: 0x808080, align: 'left'});
		visitText.position.set(100, 92);
		container.addChild(visitText);
		container.visitText = visitText;
		container.position.set(x, y);
		nodeToContainer.set(node, container);
		return viewport.addChild(container);
	}
	const root = getRoot();
	layers = [];
	function traverseTree(node, layer, maxLayer) {
		if (layers.length <= layer) layers.push([]);
		layers[layer].push(node);
		if (layer < maxLayer) {
			for (const child of node.children) {
				traverseTree(child, layer + 1, maxLayer);
			}
		}
	}
	traverseTree(root, 0, 2);
	for (let y = layers.length - 1; y >= 0; y--) {
		for (let x = 0; x < layers[y].length; x++) {
			let worldX, worldY, offset = false;
			if (y == layers.length - 1) {
				worldX = (x - layers[y].length / 2) * (y > 1 ? 70 : 110);
				worldY = y * 200;
				if (y > 1 && x % 2 == 1) {
					worldY += 120;
					offset = true;
				}
			} else {
				const children = layers[y][x].children;
				if (children.length == 0) {
					const leftNeighbor = nodeToContainer.get(layers[y][x-1]);
					worldX = leftNeighbor.position.x + 110;
				} else {
					const leftChildContainer = nodeToContainer.get(children[0]);
					const rightChildContainer = nodeToContainer.get(children[children.length - 1]);
					worldX = (leftChildContainer.position.x + rightChildContainer.position.x) / 2;
				}
				worldY = y * 200;
			}
			const container = makeContainer(layers[y][x], worldX, worldY);
			container.offset = offset;
		}
	}
	for (const node of layers.flat()) {
		if (node.parent == null) continue;
		const container = nodeToContainer.get(node);
		const parentContainer = nodeToContainer.get(node.parent);
		const dx = parentContainer.position.x - container.position.x;
		let dy = parentContainer.position.y - container.position.y + 100;
		const graphics = new PIXI.Graphics();
		graphics.lineStyle(2, 0xC0C0C0);
		graphics.moveTo(150, 100);
		let offset = 0;
		if (container.offset) {
			offset = 120;
			dy += 120;
		}
		graphics.lineTo(150, 100 - offset);
		graphics.quadraticCurveTo(150, 100 + dy / 2 - offset, 150 + dx / 2, 100 + dy / 2 - offset);
		graphics.quadraticCurveTo(150 + dx, 100 + dy / 2 - offset, 150 + dx, 100 + dy - offset);
		container.addChild(graphics);
	}
	// Update loop.
	app.ticker.add((ticker) => {
	  	for (const node of layers.flat()) {
			const container = nodeToContainer.get(node);
			container.visible = node.visits > 0 || node.parent == null || node.parent?.parent == null;
			container.text.text = node.visits == 0 ? "" : (-node.totalValue / node.visits).toFixed(2);
			let visitString = node.visits >= 1e6 ? (node.visits / 1e6).toFixed(1) + "M" : node.visits >= 1e3 ? (node.visits / 1e3).toFixed(1) + "K" : node.visits + "";
			container.visitText.text = visitString;
		}
	});
	// Interaction.
	buttonRootSim.onclick = () => {
		for (const child of root.children) {
			rolloutAndBackprop(child);
		}
	};
	buttonSelectSim.onclick = () => {
		for (let i = 0; i < 100; i++) {
		const node = select(root);
		rolloutAndBackprop(node);
		}
	};
})();